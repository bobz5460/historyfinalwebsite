<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>History Final</title>
  <script>
    history.scrollRestoration = "manual";
    window.addEventListener("DOMContentLoaded", () => {
      window.scrollTo(0, document.body.scrollHeight);
    });
  </script>
	<script src="https://unpkg.com/gsap@3/dist/gsap.min.js"></script>
	<script src="https://unpkg.com/gsap@3/dist/ScrollTrigger.min.js"></script>
	<script src="https://unpkg.com/gsap@3/dist/ScrollSmoother.min.js"></script>
	<script src="https://unpkg.com/gsap@3/dist/TextPlugin.min.js"></script>
	<script src="https://unpkg.com/split-type"></script>
	<link href="https://fonts.googleapis.com/css2?family=Inter&display=swap" rel="stylesheet">
</head>
<body>
<div class="stars-container">
  <canvas id="starsLayer1" class="stars-canvas"></canvas>
  <canvas id="starsLayer2" class="stars-canvas"></canvas>
  <canvas id="starsLayer3" class="stars-canvas"></canvas>
</div>
  <style>
    /* Image modal styles */
    .image-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 7, 37, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .image-modal.active {
      opacity: 1;
      visibility: visible;
    }

    .modal-content {
      max-width: 90%;
      max-height: 90%;
      box-shadow: 0 0 30px rgba(101, 125, 255, 0.6);
      border: 2px solid rgba(101, 125, 255, 0.5);
      transform: scale(0.9);
      transition: transform 0.3s ease;
      border-radius: 8px;
      overflow: hidden;
    }

    .image-modal.active .modal-content {
      transform: scale(1);
    }

    .modal-content img {
      display: block;
      max-width: 100%;
      max-height: 100%;
    }

    .close-modal {
      position: absolute;
      top: 20px;
      right: 30px;
      color: #cfd9ff;
      font-size: 40px;
      font-weight: bold;
      cursor: pointer;
      transition: color 0.2s ease;
      text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }

    .close-modal:hover {
      color: #ffffff;
      text-shadow: 0 0 15px rgba(101, 125, 255, 0.8);
    }

    .event-image {
      cursor: pointer;
      transition: box-shadow 0.2s ease;
    }

    .event-image:hover {
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5), 0 0 15px rgba(101, 125, 255, 0.6) !important;
    }

    .timeline {
      position: relative;
      margin: 0 auto;
      padding: 0;
      width: 4px;
      background: linear-gradient(to bottom, rgba(50, 70, 150, 0.6), rgba(101, 125, 255, 0.9));
      height: 10000px;
      box-shadow: 0 0 15px rgba(101, 125, 255, 0.4);
    }

    .timeline .fill {
      position: relative;
      bottom: 0;
      left: 0;
      width: 100%;
      background: linear-gradient(to bottom, #cfd9ff, #657dff);
      height: 0;
      transition: height 0.01s linear;
      box-shadow: 0 0 10px rgba(101, 125, 255, 0.8);
    }

    .timeline-dot {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: 16px;
      height: 16px;
      background-color: #657dff;
      border: 4px solid rgba(13, 23, 58, 0.8);
      border-radius: 50%;
      bottom: -50%;
      box-shadow: 0 0 10px 2px rgba(101, 125, 255, 0.7);
      z-index: 5;
      transition: all 0.3s ease;
    }

    .timeline-dot:hover {
      transform: translateX(-50%) scale(1.2);
      box-shadow: 0 0 15px 4px rgba(101, 125, 255, 0.9);
    }
  </style>
  <div id="smooth-wrapper">
    <div id="smooth-content">

	<link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
	<div class="timeline" id="timeline">

    <div class="event-image" style="bottom: 5.7%; right: 130px; opacity:0; visibility:hidden; transform:translateY(-70px); cursor:pointer;">
      <img src="{{ url_for('static', filename='images/coldwar.png') }}" alt="Cold War Beginning" onerror="this.onerror=null; this.src='data:image/svg+xml;charset=utf-8,%3Csvg xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22 viewBox%3D%220 0 240 180%22%3E%3Crect width%3D%22240%22 height%3D%22180%22 fill%3D%22%23113%22%2F%3E%3Ccircle cx%3D%22120%22 cy%3D%2270%22 r%3D%2240%22 fill%3D%22%23224%22 stroke%3D%22%23657dff%22 stroke-width%3D%223%22%2F%3E%3Ccircle cx%3D%22120%22 cy%3D%2270%22 r%3D%2232%22 fill%3D%22none%22 stroke%3D%22%23657dff%22 stroke-width%3D%222%22 stroke-dasharray%3D%228%2C3%22%2F%3E%3Cpath d%3D%22M80 110 L160 110%22 stroke%3D%22%23657dff%22 stroke-width%3D%223%22%2F%3E%3Ctext x%3D%22120%22 y%3D%22140%22 dominant-baseline%3D%22middle%22 text-anchor%3D%22middle%22 font-family%3D%22monospace%22 font-size%3D%2222%22 fill%3D%22%237a9bff%22%3ECold War%3C%2Ftext%3E%3C%2Fsvg%3E';">
    </div>
    <div class="timeline-dot" style="bottom: 5.5%;"></div>
    <div class="dot-label" style="bottom: 5%; opacity:0; visibility:hidden; transform:translateY(-50px);">
    	    <div class="event-title-container">
    	      <h1>The Start</h1>
    	      <span class="event-date">1955-1957</span>
    	    </div>
	    <p>At the end of World War II, tensions between the United States and the Soviet Union caused the start of the Cold War. Both superpowers began competing in everything, including science and technology. Rocketry became a key focus as both nations funded programs to advance missile and space programs. In July 1955, the U.S. announced plans to launch an artificial satellite during the International Geophysical Year. The USSR responded four days later with a similar announcement, marking the beginning of the Space Race.</p>
      </p>
    </div>

    <div class="timeline-dot" style="bottom: 20%;"></div>
    <div class="event-image" style="bottom: 20%; right: 130px; opacity:0; visibility:hidden; transform:translateY(70px); cursor:pointer;">
      <img src="{{ url_for('static', filename='images/sputnik.png') }}">
    </div>
    <div class="dot-label" style="bottom: 20%; opacity:0; visibility:hidden; transform:translateY(50%);">
      <div class="event-title-container">
        <h1>Sputnik Launch</h1>
        <span class="event-date">October 4, 1957</span>
      </div>
      <p>The Soviet Union launched Sputnik 1, the world's first artificial satellite, shocking the United States and starting the Space Race in earnest. The 184-pound, basketball-sized satellite orbited Earth for three weeks before its batteries died, and it burned up in the atmosphere in January 1958.</p>
    </div>

    <div class="timeline-dot" style="bottom: 50%;"></div>
    <div class="event-image" style="bottom: 50%; right: 130px; opacity:0; visibility:hidden; transform:translateY(70px); cursor:pointer;">
      <img src="{{ url_for('static', filename='images/nasa.png') }}" alt="NASA Establishment" onerror="this.onerror=null; this.src='data:image/svg+xml;charset=utf-8,%3Csvg xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22 viewBox%3D%220 0 240 180%22%3E%3Crect width%3D%22240%22 height%3D%22180%22 fill%3D%22%23113%22%2F%3E%3Ccircle cx%3D%22120%22 cy%3D%2270%22 r%3D%2250%22 fill%3D%22%23113%22 stroke%3D%22%237a9bff%22 stroke-width%3D%223%22%2F%3E%3Ccircle cx%3D%22120%22 cy%3D%2270%22 r%3D%2245%22 fill%3D%22none%22 stroke%3D%22%237a9bff%22 stroke-width%3D%221%22 stroke-dasharray%3D%2210%2C4%22%2F%3E%3Cpath d%3D%22M100 70 Q120 30 140 70%22 fill%3D%22none%22 stroke%3D%22%237a9bff%22 stroke-width%3D%223%22%2F%3E%3Ctext x%3D%22120%22 y%3D%2270%22 dominant-baseline%3D%22middle%22 text-anchor%3D%22middle%22 font-family%3D%22Arial%22 font-weight%3D%22bold%22 font-size%3D%2228%22 fill%3D%22%237a9bff%22%3ENASA%3C%2Ftext%3E%3Ctext x%3D%22120%22 y%3D%22140%22 dominant-baseline%3D%22middle%22 text-anchor%3D%22middle%22 font-family%3D%22monospace%22 font-size%3D%2218%22 fill%3D%22%237a9bff%22%3EEst. 1958%3C%2Ftext%3E%3C%2Fsvg%3E';">
    </div>
    <div class="dot-label" style="bottom: 50%; opacity:0; visibility:hidden; transform:translateY(50%);">
      <div class="event-title-container">
        <h1>NASA Established</h1>
        <span class="event-date">July 29, 1958</span>
      </div>
      <p>In response to Sputnik, the United States established the National Aeronautics and Space Administration (NASA) to coordinate and conduct space exploration activities. President Eisenhower signed the National Aeronautics and Space Act, officially establishing NASA as a civilian agency with a distinctly peaceful and scientific mission.</p>
    </div>


    <div class="fill" id="fillLine"></div>

</div>

<div class="container">
        <div class="earth-glow"></div>
    	    <div class="middle">
            <h1 id="welcome">Welcome to Space!</h1>
            <div class="subtitle">History of the space race</div>
        </div>
    </div>
    </div>
  </div>

  <!-- Image Modal -->
  <div class="image-modal" id="imageModal">
    <span class="close-modal" id="closeModal">&times;</span>
    <div class="modal-content">
      <img id="modalImage" src="" alt="Full size image">
    </div>
  </div>

</body>


<script>
  // Modal functionality
  document.addEventListener('DOMContentLoaded', function() {
    // Set up image modal functionality
    const modal = document.getElementById('imageModal');
    const modalImg = document.getElementById('modalImage');
    const closeBtn = document.getElementById('closeModal');

    // Add click event to all event images
    document.querySelectorAll('.event-image img').forEach(img => {
      img.addEventListener('click', function() {
        // Get the original image source
        const imgSrc = this.getAttribute('src');

        // Set the modal image source
        modalImg.setAttribute('src', imgSrc);

        // Show the modal with animation
        modal.classList.add('active');

        // Prevent body scrolling when modal is open
        document.body.style.overflow = 'hidden';
      });
    });

    // Close modal when clicking the X button
    closeBtn.addEventListener('click', closeModal);

    // Close modal when clicking outside the image
    modal.addEventListener('click', function(e) {
      if (e.target === modal) {
        closeModal();
      }
    });

    // Close modal when pressing ESC key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && modal.classList.contains('active')) {
        closeModal();
      }
    });

    function closeModal() {
      modal.classList.remove('active');
      // Restore body scrolling
      document.body.style.overflow = '';
    }

    setTimeout(() => {
      // Parameters: (id, count, maxSize, speedFactor, twinkleFactor, color, baseScrollSpeed, scrollRandom)
      initStars('starsLayer1', 70, 2.5, 0.1, 1, '#ffffff', 0.2, 0.5); // Large, fast-moving distant stars
      initStars('starsLayer2', 100, 1.5, 0.03, 0.08, '#b7c1e6', 0.1, 0.3); // Medium stars
      initStars('starsLayer3', 150, 1, 0.02, 0.05, '#657dff', 0.1, 0.1); // Small, slower nearby stars
      animateStars();
      updateStarsVisibility();
    }, 100);
  });

  // Update which stars are in the visible area
  function updateStarsVisibility() {
    // Get scroll position from ScrollSmoother if available
    let scrollY;
    const smoother = ScrollSmoother.get();

    if (smoother) {
      // Use ScrollSmoother's scroll position
      scrollY = smoother.scrollTop();
    } else {
      // Fallback to standard scroll position
      scrollY = window.scrollY || window.pageYOffset;
    }

    const viewportHeight = window.innerHeight;
    const documentHeight = document.documentElement.scrollHeight;

    Object.keys(starLayers).forEach(layerId => {
      const layer = starLayers[layerId];
      const { stars } = layer;

      stars.forEach(star => {
        // Use individual star's scroll speed with boundary protection
        // Ensure we never move stars beyond the reasonable bounds
        const maxScroll = documentHeight - viewportHeight;
        const clampedScrollY = Math.max(0, Math.min(scrollY, maxScroll));
        const relY = star.y - (clampedScrollY * star.scrollSpeed);
        star.visible = relY >= -200 && relY <= viewportHeight + 200; // Expanded visible range
      });
    });
  }

  // Store stars data
  const starLayers = {};

  // Initialize stars for a canvas layer
  function initStars(canvasId, count, maxSize, speedFactor, twinkleFactor, color, baseScrollSpeed, scrollRandom) {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext('2d');

    // Get document height for stars distribution
    const docHeight = Math.max(
      document.body.scrollHeight,
      document.body.offsetHeight,
      document.documentElement.clientHeight,
      document.documentElement.scrollHeight,
      document.documentElement.offsetHeight,
      10000 // Fallback minimum height (timeline height)
    );

    // Set canvas to cover viewport
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Create stars distributed across the full document height
    const stars = [];
    const starDensity = count / (window.innerHeight);
    const totalStars = Math.ceil(starDensity * docHeight);

    for (let i = 0; i < totalStars; i++) {
      // Calculate star size with more variation
      const starSize = Math.random() * maxSize + 0.5;
      // Adjust parallax speed based on star size for realistic depth effect
      // Smaller stars should move slower (appear closer), larger stars move faster (appear farther)
      const sizeRatio = starSize / (maxSize + 0.5); // 0-1 based on size
      const individualScrollSpeed = baseScrollSpeed + (scrollRandom * Math.random() * sizeRatio);

      stars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * docHeight, // Distribute across full document height
        originalY: 0, // Will store original position for parallax
        size: starSize,
        speed: Math.random() * speedFactor + 0.1,
        twinkle: Math.random() * twinkleFactor,
        brightness: Math.random() * 0.3 + 0.7, // Start brighter with less variation
        brightnessDelta: Math.random() * 0.002 + 0.0005, // Much slower brightness changes
        brightDirection: Math.random() > 0.5 ? 1 : -1,
        lastUpdate: Math.random() * 100, // Randomize update timing
        updateFrequency: Math.random() * 10 + 30, // Only update occasionally
        scrollSpeed: individualScrollSpeed, // Individual parallax speed for each star
        visible: false // Track visibility
      });
    }

    starLayers[canvasId] = {
      canvas,
      ctx,
      stars,
      scrollOffset: 0,
      color,
      baseScrollSpeed,
      scrollRandom
    };
  }

  // Animate all star layers
  function animateStars() {
    // Get scroll position from ScrollSmoother if available
    let scrollY;
    const smoother = ScrollSmoother.get();

    if (smoother) {
      // Use ScrollSmoother's scroll position
      scrollY = smoother.scrollTop();
    } else {
      // Fallback to standard scroll position
      scrollY = window.scrollY || window.pageYOffset;
    }

    // Get document dimensions for proper boundary handling
    const viewportHeight = window.innerHeight;
    const documentHeight = document.documentElement.scrollHeight;
    const maxScroll = documentHeight - viewportHeight;

    // Clamp scroll value to prevent stars from breaking at page boundaries
    const clampedScrollY = Math.max(0, Math.min(scrollY, maxScroll));

    Object.keys(starLayers).forEach(layerId => {
      const layer = starLayers[layerId];
      const { canvas, ctx, stars, color } = layer;

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw each star
      stars.forEach(star => {
        // Determine if star is in visible range using individual scroll speeds
        // Apply easing to scroll effect when near top/bottom boundaries
        const scrollEffect = star.scrollSpeed * (1 - Math.pow(Math.min(clampedScrollY / viewportHeight, 1), 3) * 0.3);
        const relativeY = star.y - (clampedScrollY * scrollEffect);
        const isVisible = relativeY >= -50 && relativeY <= canvas.height + 50;

        // Only process visible stars
        if (isVisible) {
          // Update counter for this star
          star.lastUpdate++;

          // Only update brightness occasionally for slower twinkling
          if (star.lastUpdate > star.updateFrequency) {
            // Twinkle effect
            star.brightness += star.brightnessDelta * star.brightDirection;

            // Constrain brightness with narrower range for subtler effect
            if (star.brightness > 0.95) {
              star.brightness = 0.95;
              star.brightDirection = -1;
              // Randomize next update frequency
              star.updateFrequency = Math.random() * 10 + 30;
            } else if (star.brightness < 0.75) {
              star.brightness = 0.75;
              star.brightDirection = 1;
              // Randomize next update frequency
              star.updateFrequency = Math.random() * 10 + 30;
            }

            // Reset counter
            star.lastUpdate = 0;
          }

          // Calculate position relative to scroll
          const drawY = relativeY;

          // Draw star with slight size variation based on scroll for extra depth effect
          // Stars that move faster should appear to vary size slightly as you scroll
          const scrollEffect = 1 + (Math.sin(scrollY * 0.001 * star.scrollSpeed) * 0.1 * star.scrollSpeed);
          const currentSize = star.size * scrollEffect;

          ctx.beginPath();
          ctx.fillStyle = color;
          ctx.globalAlpha = star.brightness;

          // Create a slight glow effect
          const glow = ctx.createRadialGradient(
            star.x, drawY, 0,
            star.x, drawY, currentSize * 2
          );

          glow.addColorStop(0, color);
          glow.addColorStop(1, 'transparent');

          ctx.fillStyle = color;
          ctx.arc(star.x, drawY, currentSize, 0, Math.PI * 2);
          ctx.fill();

          // Some stars have a subtle glow
          if (currentSize > 1.5) {
            ctx.globalAlpha = star.brightness * 0.3;
            ctx.beginPath();
            ctx.arc(star.x, drawY, currentSize * 2, 0, Math.PI * 2);
            ctx.fillStyle = glow;
            ctx.fill();
          }

          // Only move stars occasionally and very slightly for more stable background
          // Stars with higher parallax speeds (further away) should move more to enhance depth effect
          const moveProbability = 0.01 * (1 + star.scrollSpeed);
          if (Math.random() < moveProbability) {
            // Higher parallax stars move more
            const moveFactor = 0.2 * (0.5 + star.scrollSpeed);
            star.x += (Math.random() - 0.5) * star.twinkle * moveFactor;

            // Keep stars within horizontal bounds
            if (star.x < 0) star.x = canvas.width;
            if (star.x > canvas.width) star.x = 0;
          }
        }
      });
    });

    requestAnimationFrame(animateStars);
  }

	gsap.registerPlugin(ScrollTrigger, ScrollSmoother, TextPlugin, SplitType);
    ScrollSmoother.create({
  smooth: 1,
  effects: true,
  smoothTouch: 0.1,
});
    gsap.registerEffect({
  name: "fade",
  effect: (targets, config) => {
    return gsap.to(targets, { duration: config.duration, opacity: 100 });
  },
  defaults: { duration: 1 },
  extendTimeline: true,
});
	const welcome = new SplitType("#welcome");
	// Create a timeline for the welcome text animation
	const welcomeTl = gsap.timeline();

	// Initialize welcome text animation


	// Initial animation: characters flying in together
	welcomeTl.to('.char', {
        stagger: 0.05,
		y: 0,
		delay: 0.5,
		duration: 0.6,
		ease: "back.out(1.5)"
	});

	// Add a slight scale bounce to each character (all at once for uniformity)
	welcomeTl.to('.char', {
        stagger: 0.04,
		scale: 1.1,
		duration: 0.1,
		ease: "power2.out"
	}, "-=0.2");

	// Return to normal scale (all at once for uniformity)
	welcomeTl.to('.char', {
        stagger: 0.04,
		scale: 1,
		duration: 0.1,
		ease: "power2.in"
	});

	// Apply a continuous glow effect to the entire text
	welcomeTl.to('#welcome', {
		duration: 2,
		textShadow: '0 0 12px rgba(101, 125, 255, 0.8), 0 0 20px rgba(101, 125, 255, 0.4)',
		ease: "sine.inOut",
		yoyo: true,
		repeat: -1
	});
	  // Parallax is now handled directly in the star animation loop
	gsap.to(".earth", {
	  backgroundPositionY: "-=10000x",
	  ease: "none",
	  scrollTrigger: {
	    trigger: "body",
	    start: "top top",
	    end: "bottom bottom",
	    scrub: true
	  }
	});

	// Add subtle parallax to the right content area
	gsap.to(".moon-content-right", {
	  y: "-15%",
	  ease: "none",
	  scrollTrigger: {
	    trigger: ".moon-landing-section",
	    start: "top bottom",
	    end: "bottom top",
	    scrub: true
	  }
	});

  document.addEventListener("DOMContentLoaded", () => {
    // Ensure all dot-labels and event images are hidden before animation
    gsap.set(document.querySelectorAll('.dot-label, .event-image'), {
      autoAlpha: 0,
      y: -50
    });

    let smoother;
    let timelineHeight;
    let fillLine = document.getElementById("fillLine");

    // Rocket timeline removed

    const setupScrollTrigger = () => {
      if (!smoother) {
        setTimeout(setupScrollTrigger, 100);
        return;
      }

      // Connect ScrollSmoother to star updates
      smoother.effects('.stars-container', {speed: 1, lag: 0.5});

      // Update stars when ScrollSmoother updates
      ScrollTrigger.addEventListener('refresh', updateStarsVisibility);
      smoother.effects(false, {onUpdate: updateStarsVisibility});

      const timeline = document.getElementById("timeline");
      timelineHeight = timeline.offsetHeight;
      fillLine.style.position = "absolute";
      fillLine.style.bottom = "0";
      fillLine.style.height = "100%";

      ScrollTrigger.create({
        trigger: "#timeline",
        start: "top bottom",
        end: "bottom top",
        onUpdate: self => {

          const timelineRect = timeline.getBoundingClientRect();
          const viewportHeight = window.innerHeight;
          const timelineTop = timelineRect.top;
          const timelineBottom = timelineRect.bottom;
          const timelineHeight = timelineRect.height;


          let progress;
          if (timelineBottom <= 0) {
            progress = 0;
          } else if (timelineTop >= viewportHeight) {
            progress = 1;
          } else {
            // Correct progress: 1 at bottom, 0 at top
            progress = (timelineBottom - viewportHeight) / (timelineHeight - viewportHeight);
            progress = Math.max(0, Math.min(1, progress));
          }
          // Set fill height (starts at 100%, shrinks to 0%)
          fillLine.style.height = (progress * 100) + "%";
        },
        invalidateOnRefresh: true
      });

      document.querySelectorAll('.dot-label').forEach(label => {
        const tl = gsap.timeline({
          scrollTrigger: {
            trigger: label,
            start: "center bottom",
            end: "center top-=150",
            toggleActions: "play reverse play reverse",
            markers: false
          }
        });

        tl.set(label, {autoAlpha: 0, y: 20})
          .to(label, {
            autoAlpha: 1,
            y: 0,
            duration: 0.8,
            ease: "power3.out"
          })
          .from(label.querySelector('.event-title-container h1'), {
            opacity: 0,
            y: 10,
            duration: 0.5,
            ease: "back.out(1.4)"
          }, "-=0.4")
          .from(label.querySelector('.event-date'), {
            opacity: 0,
            x: -10,
            duration: 0.4,
            ease: "power2.out"
          }, "-=0.3")
          .from(label.querySelector('p'), {
            opacity: 0,
            y: 10,
            duration: 0.5,
            ease: "power2.out"
          }, "-=0.2");
      });
      document.querySelectorAll('.event-image').forEach(image => {
        const tl = gsap.timeline({
          scrollTrigger: {
            trigger: image,
            start: "center bottom",
            end: "center top-=150",
            toggleActions: "play reverse play reverse",
            markers: false
          }
        });

        tl.set(image, {autoAlpha: 0, x: 70})
          .to(image, {
            autoAlpha: 1,
            x: 0,
            duration: 1,
            ease: "power3.out"
          })
          .from(image.querySelector('img'), {
            scale: 1.15,
            filter: "brightness(0.8)",
            duration: 1.5,
            ease: "power2.out"
          }, "-=0.6")
          .to(image, {
            boxShadow: "0 8px 25px rgba(0, 0, 0, 0.4), 0 0 15px rgba(101, 125, 255, 0.5)",
            duration: 1.2
          }, "-=1.2");
      });
      // Initialize bottom labels and images to be visible on page load since we start at the bottom
      setTimeout(() => {
        const viewportHeight = window.innerHeight;
        document.querySelectorAll('.dot-label, .event-image').forEach(element => {
          const bottom = parseFloat(element.style.bottom) || 0;
          if (bottom <= 20) {
            if (element.classList.contains('event-image')) {
              gsap.set(element, {opacity: 1, x: 0, visibility: 'visible'});
            } else {
              gsap.set(element, {opacity: 1, y: 0, visibility: 'visible'});
            }
          }
        });
      }, 500);
    };

    const checkSmoother = () => {
      smoother = ScrollSmoother.get();
      if (smoother) {
        setupScrollTrigger();
      } else {
        setTimeout(checkSmoother, 100);
      }
    };
        setTimeout(() => {
    const viewportHeight = window.innerHeight;
    window.scrollTo({
      top: document.documentElement.scrollTop - viewportHeight,
      behavior: 'smooth'
    });
  }, 4000);
    checkSmoother();
  });

</script>